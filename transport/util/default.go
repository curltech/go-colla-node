package util

import (
	"crypto/tls"
	"errors"
	"github.com/curltech/go-colla-core/config"
	"github.com/curltech/go-colla-core/logger"
	"github.com/valyala/fasthttp"
	"golang.org/x/crypto/acme"
	"golang.org/x/crypto/acme/autocert"
	"net"
	"net/http"
	"strings"
)

func FastHttpServeTLS(listener net.Listener, handler func(ctx *fasthttp.RequestCtx), cert string, key string) error {
	if cert == "" || key == "" {
		return errors.New("NoTLSCertKey")
	}
	logger.Sugar.Infof("Proxying calls from https://%s to %s started!", listener.Addr().String())
	err := fasthttp.ServeTLS(listener, cert, key, handler)
	if err != nil {
		logger.Sugar.Errorf("failed to fasthttp.ListenAndServeTLS: %v", err.Error())
	}
	return err
}

func HttpServeTLS(listener net.Listener, handler http.Handler, cert string, key string) error {
	if cert == "" || key == "" {
		return errors.New("NoTLSCertKey")
	}
	logger.Sugar.Infof("Proxying calls from https://%s to %s started!", listener.Addr().String())
	err := http.ServeTLS(listener, handler, cert, key)
	if err != nil {
		logger.Sugar.Errorf("failed to http.ListenAndServeTLS: %v", err.Error())
	}
	return err
}

func FastHttpListenAndServeTLS(addr string, cert string, key string, handler func(ctx *fasthttp.RequestCtx)) error {
	if cert == "" || key == "" {
		return errors.New("NoTLSCertKey")
	}
	logger.Sugar.Infof("Proxying calls from https://%s to %s started!", addr)
	err := fasthttp.ListenAndServeTLS(addr, cert, key, handler)
	if err != nil {
		logger.Sugar.Errorf("failed to fasthttp.ListenAndServeTLS: %v", err.Error())
	}
	return err
}

func HttpListenAndServeTLS(addr string, cert string, key string, handler http.Handler) error {
	if cert == "" || key == "" {
		return errors.New("NoTLSCertKey")
	}
	logger.Sugar.Infof("Proxying calls from https://%s to %s started!", addr)
	err := http.ListenAndServeTLS(addr, cert, key, handler)
	if err != nil {
		logger.Sugar.Errorf("failed to http.ListenAndServeTLS: %v", err.Error())
	}
	return err
}

func FastHttpLetsEncrypt(addr string, domain string, handler func(ctx *fasthttp.RequestCtx)) error {
	logger.Sugar.Infof("Domain specified, using LetsEncrypt to autogenerate and serve certs for %s\n", domain)
	// 必须使用443
	if !strings.HasSuffix(addr, ":443") {
		logger.Sugar.Infof("WARN: Right now, you must serve on port :443 to use autogenerated LetsEncrypt certs using the -domain flag, this may NOT WORK")
	}
	m := &autocert.Manager{
		Cache:      autocert.DirCache("certs"),
		Prompt:     autocert.AcceptTOS,
		HostPolicy: autocert.HostWhitelist(config.TlsParams.Domain),
	}

	cfg := &tls.Config{
		GetCertificate: m.GetCertificate,
		NextProtos: []string{
			"http/1.1", acme.ALPNProto,
		},
	}

	// Let's Encrypt tls-alpn-01 only works on port 443.
	ln, err := net.Listen("tcp4", addr) /* #nosec G102 */
	if err != nil {
		logger.Sugar.Errorf("failed to server.Listen: %v", err.Error())
		return err
	}

	lnTls := tls.NewListener(ln, cfg)

	if err := fasthttp.Serve(lnTls, handler); err != nil {
		if err != nil {
			logger.Sugar.Errorf("failed to fasthttp.Serve: %v", err.Error())
			return err
		}
	}

	return err
}

func HttpLetsEncrypt(addr string, domain string, handler http.Handler) error {
	logger.Sugar.Infof("Domain specified, using LetsEncrypt to autogenerate and serve certs for %s\n", domain)
	// 必须使用443
	if !strings.HasSuffix(addr, ":443") {
		logger.Sugar.Infof("WARN: Right now, you must serve on port :443 to use autogenerated LetsEncrypt certs using the -domain flag, this may NOT WORK")
	}
	m := &autocert.Manager{
		Cache:      autocert.DirCache("certs"),
		Prompt:     autocert.AcceptTOS,
		HostPolicy: autocert.HostWhitelist(config.TlsParams.Domain),
	}
	server := &http.Server{
		Addr:      addr,
		TLSConfig: m.TLSConfig(),
	}
	server.Handler = handler
	err := server.ListenAndServeTLS("", "")
	if err != nil {
		logger.Sugar.Errorf("failed to server.ListenAndServeTLS: %v", err.Error())
		return err
	}

	return err
}

func FastHttpLetsEncryptServe(listener net.Listener, domain string, handler func(ctx *fasthttp.RequestCtx)) error {
	logger.Sugar.Infof("Domain specified, using LetsEncrypt to autogenerate and serve certs for %s\n", domain)
	// 必须使用443
	if !strings.HasSuffix(listener.Addr().String(), ":443") {
		logger.Sugar.Infof("WARN: Right now, you must serve on port :443 to use autogenerated LetsEncrypt certs using the -domain flag, this may NOT WORK")
	}
	m := &autocert.Manager{
		Cache:      autocert.DirCache("certs"),
		Prompt:     autocert.AcceptTOS,
		HostPolicy: autocert.HostWhitelist(config.TlsParams.Domain),
	}

	cfg := &tls.Config{
		GetCertificate: m.GetCertificate,
		NextProtos: []string{
			"http/1.1", acme.ALPNProto,
		},
	}

	// Let's Encrypt tls-alpn-01 only works on port 443.
	//ln, err := net.Listen("tcp4", addr) /* #nosec G102 */
	//if err != nil {
	//	logger.Sugar.Errorf("failed to server.Listen: %v", err.Error())
	//	return err
	//}

	lnTls := tls.NewListener(listener, cfg)
	err := fasthttp.Serve(lnTls, handler)
	if err != nil {
		if err != nil {
			logger.Sugar.Errorf("failed to fasthttp.Serve: %v", err.Error())
			return err
		}
	}

	return err
}

func HttpLetsEncryptServe(listener net.Listener, domain string, handler http.Handler) error {
	logger.Sugar.Infof("Domain specified, using LetsEncrypt to autogenerate and serve certs for %s\n", domain)
	// 必须使用443
	if !strings.HasSuffix(listener.Addr().String(), ":443") {
		logger.Sugar.Infof("WARN: Right now, you must serve on port :443 to use autogenerated LetsEncrypt certs using the -domain flag, this may NOT WORK")
	}
	m := &autocert.Manager{
		Cache:      autocert.DirCache("certs"),
		Prompt:     autocert.AcceptTOS,
		HostPolicy: autocert.HostWhitelist(config.TlsParams.Domain),
	}
	server := &http.Server{
		Addr:      listener.Addr().String(),
		TLSConfig: m.TLSConfig(),
	}
	server.Handler = handler
	err := server.ServeTLS(listener, "", "")
	if err != nil {
		logger.Sugar.Errorf("failed to server.ListenAndServeTLS: %v", err.Error())
		return err
	}

	return err
}
